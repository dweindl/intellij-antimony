{
  parserClass="com.github.dweindl.intellijantimony.parser.AntimonyParser"
  parserUtilClass="com.github.dweindl.intellijantimony.parser.AntimonyParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Antimony"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.dweindl.intellijantimony.psi"
  psiImplPackage="com.github.dweindl.intellijantimony.psi.impl"

  elementTypeHolderClass="com.github.dweindl.intellijantimony.psi.AntimonyTypes"
  elementTypeClass="com.github.dweindl.intellijantimony.psi.AntimonyElementType"
  tokenTypeClass="com.github.dweindl.intellijantimony.psi.AntimonyTokenType"

  psiImplUtilClass="com.github.dweindl.intellijantimony.psi.impl.AntimonyPsiImplUtil"


  tokens=[
    SEMI=';'
    COLON=':'
    PRIME="'"
    COMMA=','
    MODEL='regexp:(model|module)'
    END='end'
    VAR='var'
    CONST='const'
    SPECIES='species'
    COMPARTMENT='compartment'
    IS='is'
    IN='in'
    AT='at'
    NOTES='notes'
    HAS='has'
    UNIT_KEYWORD='unit'
    EOL = "regexp:\s*(\n|\r\n)\s*"
    WHITE_SPACE="regexp:[ \t\x0B\f\r]+"
    LINE_COMMENT = "regexp:(//|#).*"
    // ".|\n" does not match all characters, because "." excludes all Unicode newline chars - use "[^]" instead
    BLOCK_COMMENT='regexp:/\*([^])*\*/'
    PLUS='+'
    MINUS='-'
    MUL='*'
    DIV='/'
    POW='^'
    LPAREN='('
    RPAREN=')'
    EQ='='
    ASSIGN_EQ=':='
    ID='regexp:[a-zA-Z_][a-zA-Z_0-9]*'
    INT='regexp:\d+'
    FLOAT='regexp:\d+\.\d*|\.\d+'
    SCIENTIFIC='regexp:(\d+(\.\d*)?|\.\d+)[eE][-+]?\d+'
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    BACKSLASH='\'
    DOT='.'
    DOLLAR='$'
    // TODO: double-check operators
  AND='&&'
  OR='||'
  NOT='!'
  EQEQ='=='
  NEQ='!='
  LT='<'
  LTE='<='
  GT='>'
  GTE='>='


  ]
    name(".*expr")='expression'
    extends(".*expr")=expr
}

antimonyFile ::= root_item *
private root_item    ::= (module | module_body | model_annotation)
module       ::= MODEL model_id "(" ")" module_body? END
model_id     ::= identifier
module_body  ::= module_body_item +
private module_body_item ::=
    EOL
    | annotation
    | assignment
    | rate_rule
    | assignment_rule
    | reaction
    | unit_annotation
    | annotation_is
    | declaration
    | unit_definition
    | modifier_annotation
    | event_definition

rate_rule ::= identifier "'" EQ expr (SEMI | EOL | LINE_COMMENT) {pin=2}
assignment ::= declaration_body "'"? EQ expr (SEMI | EOL | LINE_COMMENT)
assignment_rule ::= declaration_body (":=" | "=") expr ((SEMI EOL+) | SEMI | EOL+ | <<eof>>)
number_literal ::= ('+'|'-') ? (INT | FLOAT | SCIENTIFIC)

declaration ::= declaration_body (SEMI | EOL)
declaration_body ::= ("var" | "const")? ( "compartment" | "species" )? identifier ("in" compartment_id)? (SEMI | EOL)?
compartment_id ::= identifier
annotation ::= identifier "notes" string (SEMI | EOL)
unit_annotation ::= identifier "has" unit (SEMI | EOL)
annotation_is::=identifier "is" string (SEMI | EOL)
// TODO: needs to have a unit included
unit_definition ::= "unit" identifier EQ expr (SEMI | EOL)
modifier_annotation ::= (modifier_id ":")? ("-|" | "-o" | "-(") reaction_id (SEMI | EOL)
modifier_id ::= identifier


expr ::= logical_expr | arithmetic_expr
logical_expr ::= logical_term or_expr *
left or_expr ::= OR logical_term
logical_term ::= not_expr and_expr *
left and_expr ::= AND not_expr
not_expr ::= NOT? comparison_expr
comparison_expr ::= arithmetic_expr comparison_op? arithmetic_expr
comparison_op ::= EQEQ | NEQ | LT | LTE | GT | GTE

arithmetic_expr ::= (BACKSLASH EOL)* factor plus_expr *left plus_expr ::= plus_op factor
private plus_op ::= ('+'|'-') (BACKSLASH EOL)*
private factor ::= primary mul_expr * (BACKSLASH EOL)*
left mul_expr  ::= mul_op primary
private mul_op ::= ('*'|'/') (BACKSLASH EOL)*
private primary ::= primary_inner (BACKSLASH EOL)*  power_expr? // factorial_expr ?
left power_expr ::= '^' primary
private primary_inner ::= ('+'|'-') ? (literal_expr | function_call | ref_expr | paren_expr)
paren_expr ::= ('-(' | '(') expr ')' {pin=1}
ref_expr ::= identifier
literal_expr ::= number_literal unit ?
unit ::= identifier
function_call ::= function_name '(' function_arguments? ')' {pin=2}
function_arguments ::= expr (',' expr)*
function_name ::= identifier

identifier ::= ID {
    mixin="com.github.dweindl.intellijantimony.psi.impl.AntimonyNamedElementImpl"
    implements="com.github.dweindl.intellijantimony.psi.AntimonyNamedElement"
    // methods=[ getName setName getNameIdentifier getPresentation]
    methods=[getNameIdentifier setName]
}


reaction ::= (reaction_id ":")? reactants? ("->"|"=>") products? SEMI rate_expr (SEMI | EOL | <<eof>>)
reaction_id ::= identifier
reactants ::= list_of_reactants
products::= list_of_reactants
// TODO allow empty list
private list_of_reactants ::= species_expr (PLUS species_expr)*
species_expr ::= stoichiometry? "$"? species_id
stoichiometry ::= number_literal
species_id ::= identifier
rate_expr ::= expr

event_definition ::= event_trigger ":" (BACKSLASH EOL)* event_assignments (SEMI | EOL)
event_trigger ::= "at" expr
event_assignments ::= event_assignment ("," (BACKSLASH EOL)* event_assignment)*
event_assignment ::= identifier EQ expr


model_annotation ::= model_id annotation_type string (SEMI | EOL)
annotation_type ::= identifier "." identifier
// TODO predefined units
// TODO predefined functions - min max exp...